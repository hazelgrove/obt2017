Programming language definitions assign meaning to \textit{complete}
programs. Programmers, however, spend a substantial amount of time
interacting with \textit{incomplete} programs, using tools like program
editors or live programming environments that interleave editing and
evaluation. Semanticists have paid comparatively little attention to these
interactions, so the designers of tools like these lack foundational
principles comparable to those available to language designers. For
example, in languages like Agda that do have some notion of incomplete
programs, either their evaluation is not permitted or is only permitted in
cases where the evaluation trace happens to not reveal any
incompletenesses~\cite{norell:thesis}.

In our paper describing the core calculus of Hazelnut, we give static
meaning to programs with holes in them~\cite{DBLP:journals/corr/OmarVHAH16}.
Attempting to understand evaluation for such a language is a natural
continuation of this work, and would enable a programmer to smoothly
transition between editing and exploring the behavior of partial solutions.

The main challenge is to recover a meaningful notion of type safety---we
seek recognizable statements of progress and preservation for terms with
holes in them \MattSays{introduce the term ``hole'' earlier, when you talk about incomplete programs in paragraph 1}, with respect to a dynamic semantics that matches our
intuition.

Hazelnut also gives static meaning to \MattSays{``edit action''?} transitions between programs with
holes in them, giving a rich metatheory for the process of writing and
editing programs. The next step in this facet of the work amounts to live
programming writ large~\cite{burckhardt2013s}. The existing live
programming tools do not let the programmer run programs that are not complete
yet unless a placeholder value is used to make them seem complete.

In the ideal system, a Hazelnut programmer writes their
program with confidence that her edits are all safe. When she arrives at a
term that she wants to explore more, she can run the incomplete program on
some test values and can observe how the holes in her program are actually
used. She can then return to editing with new intuition about how to
combine the ingredients available to her at each incomplete location to
achieve her goals \MattSays{The term ``ingredients available to her'' is not clear in this last sentence; maybe, ``new intuition about the run-time behavior of her program, including concrete values of variables''?}

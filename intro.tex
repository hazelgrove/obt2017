Programming language definitions assign meaning to \textit{complete}
programs. Programmers, however, spend a substantial amount of time
interacting with \textit{incomplete} programs using tools like program
editors, or live programming environments thatinterleave editing and
evaluation. Semanticists have paid comparatively little attention to these
interactions, so the designers of tools like these lack foundational
semantic principles comparable to those available to language designers.

In our paper describing the core calculus of Hazelnut, we give static
meaning to programs with holes in them.\cite{} Attempting to understand
evaluation for such a language is a natural continuation of this work. The
main challenge is to recover a meaningful notion of type safety---we seek
recognizable statements of progress and preservation for terms with holes
in them, with respect to a dynamic semantics that matches our intuition.

Hazelnut also gives static meaning to transitions between programs with
holes in them, giving a rich metatheory for the process of writing and
editing programs. The next step in this facet of the work amounts to live
programming writ large. \cite{} The existing live programming tools do not
let a the programmer run programs that aren't done yet unless a placeholder
value is used to make them seem complete.

In the ideal system, a Hazelnut programmer would be able to write their
program with confidence that her edits are all safe. When she arrives at a
term that she wants to explore more, she can run the incomplete program on
some test values and observing how the holes in her program are actually
used. She can then return to editing with new intuition about how to
combine the ingredients available to her at each incomplete location to
achieve her goals.





%% In Hazelnut, we describe a simple lambda calculus that allows holes to
%% appear in terms. The goal of this work is to give a formal description of
%% the process of editing programs---and to give static meaning to every edit
%% action on partially finished programs as well as every intermediate state
%% that arises in a sequence of edits.

%% To that end, holes in Hazelnut may appear in types as well as
%% expressions. The type system of Hazelnut gives static meaning to these
%% terms. On top of that we provide an editing semantics that describes
%% transformations between terms with holes in them, and prove a rich
%% metatheory about what edits are possible. Hazelnut's edit semantics uses a
%% notion of non-empty holes to allow programmers to write terms that are not
%% type consistent with their surroundings by delaying the type consistency
%% check until the programmer alerts the system that the term under
%% construction has been finished.

%% What Hazelnut does not provide is a way to \emph{run} programs before
%% they've been finished. In some sense, an evaluation semantics for terms
%% with holes in them is the ultimate debugging tool: if a programmer is
%% writing a program and she knows the general structure of what she wants to
%% write, but only has some idea of how to fill in all the holes, she can run
%% that program to see how each hole is actually used, and what information is
%% available at each step, to develop strong intuition about how to use that
%% information to achieve her goals.

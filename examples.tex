To motivate a dynamic semantics for partial programs, we consider a series
of examples of how terms with holes in them might step and why.

Since complete terms coincide exactly with the simply typed lambda
calculus, the dynamic semantics for them are well understood. Therefore,
all the examples here are terms with holes in them. We explore the space of
what could happen to incomplete terms during evaluation by considering
different structures.

These examples are written in the style of an eager evaluation. It is not
clear to us if that is important, or what the all of the tradeoffs would
be, so this should be considered a stylistic detail that is not set in
stone.

Throughout, we write $\hehole$ to denote a hole in a program and $\mapsto$
for the relation defining a small-step dynamic semantics.

\subsection{Current Hazelnut}
First, we will consider some examples that are within the small lambda
calculus given by Hazelnut.

The judgement form $\pval{\hexp}$ is derivable when a potentially
incomplete term is a value:
\begin{align*}
  \pval{(\hlam{x}{ \hadd{9}{\hehole}})}
\end{align*}

A function applied to a value steps to the substitution as usual:
\begin{align*}
  \pstep
      {
        \hap{\hlam{x}{\hadd{9}{\hehole}}}{5}
      }
      {
        \hadd{9}{\hehole}
      }
      \\
      \pstep
      {
        \hap{\hlam{x}{\hadd{x}{\hehole}}}{5}
      }
      {
        \hadd{5}{\hehole}
      }
\end{align*}

Substitutions also occur inside non-empty holes: otherwise, free variables
would appear in the result, which would break any familiar notion of
preservation.
\begin{align*}
  \pstep
      {
        \hap{\hlam{x}{\hadd{x}{\hhole{x}}}}{5}
      }
      {
        \hadd{5}{\hhole{5}}
      }
\end{align*}

The first non-trivial choice is to also evaluate inside the non-empty hole
when possible.
%
\MattSays{Need to introduce the concept of a non-empty hole earlier, including the notation.  Perhaps introduce the concept in the intro, and the notation at the beginning of this section.}
%
This follows from the motivation that a programmer may run a incomplete
program in order to gain insight into what she has written so far:
\begin{align*}
  \pstep{
    \pstep
        {
          \hap{\hlam{x}{\hadd{x}{\hhole{\hadd{x}{x}}}}}{5}
        }
        {
          \hadd{5}{\hhole{\hadd{5}{5}}}
        }
  }{\hadd{5}{\hhole{10}}}
\end{align*}

\subsection{Possible Extensions}
Now we consider a more realistic example outside the language of
Hazelnut. Here we use an ML-like syntax that should be understood
intuitively. We intend to extend the language to include constructs like
pattern matching, algebraic datatypes, and recursive functions. We believe
an understanding of the dynamic semantics of such terms will help guide
that extension.

Imagine a programmer implementing $$\mathbf{map} : (\alpha \to \beta) \to
\alpha ~\mathit{list} \to \beta ~\mathit{list}$$ for the first time.
Provided with the informal specification that the function be applied to
every element of the list uniformly, she might arrive at the incomplete
term
\begin{lstlisting}
fun map f l =
  case l of
     []    => $\hehole$
   | x::xs => (f x)::$\hehole$
\end{lstlisting}
To see how this partial solution acts, she could then run it on a small
example:
\begin{lstlisting}
   map ($\lambda x.$x+1) [1, 2]
$\mapsto$ (($\lambda x.$x+1) 1)::$\hehole$
$\mapsto$ (1+1)::$\hehole$
$\mapsto$ 2::$\hehole$
\end{lstlisting}
This trace reveals that the solution meets the specification so far but, by
omitting a recursive call, drops the tail of the list.


Alternatively, from the same task, the programmer might have produced the
incomplete program
\begin{lstlisting}
fun map f l =
  case l of
      []    => $\hehole$
    | x::xs => $\hehole$::(map f l)
\end{lstlisting}
if they know the pattern of recursion they wish to follow, but are not sure
what to do with each element yet. Here, evaluating the same term produces a
longer trace: because the body of the function is not yet final after
substitution, the function calls go through.
\begin{verbatim}
  trace goes here
\end{verbatim}

Finally, if our programmer had an idea about how to produce the answer for
each element but was not willing to commit to it yet, she might produce
this incomplete term:
\begin{lstlisting}
fun map f l =
  case l of
      [] => $\hehole$
    | x :: xs => $\hhole{\texttt{ f x }}$ :: (map f l)
\end{lstlisting}
This would produce a trace that reveals what the particular choice would
look like at each step without actually commiting to it---at which time
this would look like a very strong candidate implementation:
\begin{verbatim}
  trace goes here
\end{verbatim}

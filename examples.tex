Following our Hazelnut work, such incomplete terms and their types are
given by
\begin{align*}
  \htau & ::=
  \tarr{\htau}{\htau} ~\vert~
  \tnum ~\vert~
  \tehole{u}
  \\
  \hexp & ::=   x ~\vert~
  \hlam{x}{\hexp} ~\vert~
  \hap{\hexp}{\hexp} ~\vert~
  \hnum{n} ~\vert~
  \hadd{\hexp}{\hexp} ~\vert~
  (\hexp : \htau) ~\vert~
  \hehole{u} ~\vert~
  \hhole{\hexp}{u}
\end{align*}
where $\hehole{u}$ and $\hhole{\hexp}{u}$ are holes named $u$ and the
latter contains $\hexp$. Hole names are unique. We write $\mapsto$ for the
small-step relation. The judgement form $\pval{\hexp}$ is derivable when a
potentially incomplete term is a value, whereas $\pindet{\hexp}$ is
derivable when a potentially incomplete term is a
\textit{indeterminate}---when its evaluation cannot proceed because of a
hole in a critical place.
\begin{align*}
  \pval{(\hlam{x}{ \hadd{9}{\hehole{u}}})}\\
  \pindet{\hadd{9}{\hehole{u}}}
\end{align*}

To motivate a dynamic semantics for incomplete programs, we consider a
series of examples of how terms with holes in them might be evaluated. In
each, evaluation continues until the term in question is either a value or
indeterminate.

\subsection{Current Hazelnut}
A function applied to a value steps to the substitution as usual:
\begin{align*}
      \pstep
      {
        \hap{\hlam{x}{\hadd{x}{\hehole{u}}}}{5}
      }
      {
        \hadd{5}{\hehole{u}}
      }
\end{align*}
Substitutions occur inside non-empty holes, even if the type of the
contents is not yet consistent with its surroundings. Otherwise, free
variables would appear in the result, breaking any familiar notion of
preservation. For instance, if $f : \tarr{\tnum}{\tarr{\tnum}{\tnum}}$,
\begin{align*}
  \pstep
      {
        \hap{\hlam{x}{\hadd{x}{\hhole{f~x}}{u}}}{5}
      }
      {
        \hadd{5}{\hhole{f~5}{u}}
      }
\end{align*}

\subsection{Extended Hazel}
To consider writing a more realistic program, we use an ML-like syntax
outside Hazelnut that should be understood intuitively. We believe an
understanding of the dynamic semantics will guide an extension of Hazelnut
to include constructs like pattern matching, ADTs, and recursive functions.

Imagine a programmer implementing $$\mathbf{map} : (\alpha \to \beta) \to
\alpha ~\mathit{list} \to \beta ~\mathit{list}$$ from the informal
specification that the function be applied to every list element uniformly.
She might arrive at the incomplete term
\begin{lstlisting}
fun map f [] = []
  | map f (x::xs) = $\hehole{u}$::(map f l)
\end{lstlisting}
if she knows the pattern of recursion, but is not sure what to do with each
element. Evaluating this incomplete program on a small example produces a
trace: because the body of the function after substitution is not a value
and not indeterminate, evaluation continues.
\begin{lstlisting}
   map ($\lambda x.$x+1) [1, 2]
$\mapsto^*$ $\hehole{u}$::(map ($\lambda x.$x+1) [2])
$\mapsto^*$ $\hehole{u}$::$\hehole{u}$::(map ($\lambda x.$x+1) [])
$\mapsto^*$ $\hehole{u}$::$\hehole{u}$::[]
\end{lstlisting}
Each hole in the trace has an associated environment with the overall goal
type for the hole and a mapping from in-scope variables names and their
types to run-time values. The environments for the last two holes above are
in Table \ref{tabx}; note that the same hole may appear multiple times in a
trace and, therefore, with different environments.

\begin{table}[h!]
  \begin{subtable}{.5\linewidth}
    \caption{goal: int (from $\beta$)}
    \centering
        {
          \footnotesize
          \begin{tabular}{c|c|c}
            var & $\htau$ & val\\
            \hline
            \texttt{f} & $int \to int$ & $\lambda x.x$\texttt{+1}\\
            \texttt{l} & $int ~list$ & \texttt{[1,2]}\\
            \texttt{x} & $int$ & \texttt{1}\\
            \texttt{xs} & $int ~list$ & \texttt{[2]}\\
          \end{tabular}
        }
  \end{subtable}%
  \begin{subtable}{.5\linewidth}
    \caption{goal: int (from $\beta$)}
    \centering
        {
          \footnotesize
          \begin{tabular}{c|c|c}
            var & $\htau$ & val\\
            \hline
            \texttt{f} & $int \to int$ & $\lambda x.x$\texttt{+1}\\
            \texttt{l} & $int ~list$ & \texttt{[2]}\\
            \texttt{x} & $int$ & \texttt{2}\\
            \texttt{xs} & $int ~list$ & \texttt{[]}\\
          \end{tabular}
        }
  \end{subtable}
  \caption{hole environments at end of trace}
  \label{tabx}
\end{table}

This trace might lead the programmer to have more confidence about their
solution so far, and to have a good idea for a candidate
completion---namely filling the hole with $\hhole{\texttt{f x}}{u}$. If she
makes this change and then reruns her example, she will see that she has
indeed satisfied the specification, and should now replace the hole with
its contents:
\begin{lstlisting}
   map ($\lambda x.$x+1) [1, 2]
$\mapsto^*$ $\hhole{\hap{(\lambda x.x+1)}{1}}{u}$::(map ($\lambda x.$x+1) [2])
$\mapsto^*$ $\hhole{\hadd{1}{1}}{u}$::(map ($\lambda x.$x+1) [2])
$\mapsto^*$ $\hhole{2}{u}$::(map ($\lambda x.$x+1) [2])
$\mapsto^*$ $\hhole{2}{u}$::$\hhole{\hap{\lambda x.x+1}{2}}{u}$::(map ($\lambda x.$x+1) [])
$\mapsto^*$ $\hhole{2}{u}$::$\hhole{\hadd{2}{1}}{u}$::(map ($\lambda x.$x+1) [])
$\mapsto^*$ $\hhole{2}{u}$::$\hhole{3}{u}$::(map ($\lambda x.$x+1) [])
$\mapsto^*$ $\hhole{2}{u}$::$\hhole{3}{u}$::[]
\end{lstlisting}

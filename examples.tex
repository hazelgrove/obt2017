To motivate a dynamic semantics for partial programs, we consider a series
of examples of how terms with holes in them might step and why.

Since complete terms coincide exactly with the simply typed lambda
calculus, the dynamic semantics for them are well understood. Therefore,
all the examples here are terms with holes in them. We explore the space of
what could happen to incomplete terms during evaluation by considering
different structures.

These examples are written in the style of an eager evaluation. It is not
clear to us if that is important, or what the all of the tradeoffs would
be, so this should be considered a stylistic detail that is not set in
stone.

We write $\hehole_i$ for a hole in a program named $i$, $\hhole{\hexp}_i$
for a non-empty hole named $i$ containing $\hexp$, and $\mapsto$ for the
small-step relation. Hole names are globally unique.

\subsection{Current Hazelnut}
First, we will consider some examples that are within the small lambda
calculus given by Hazelnut.

The judgement form $\pval{\hexp}$ is derivable when a potentially
incomplete term is a value:
\begin{align*}
  \pval{(\hlam{x}{ \hadd{9}{\hehole_1}})}
\end{align*}

A function applied to a value steps to the substitution as usual:
\begin{align*}
  \pstep
      {
        \hap{\hlam{x}{\hadd{9}{\hehole_1}}}{5}
      }
      {
        \hadd{9}{\hehole_1}
      }
      \\
      \pstep
      {
        \hap{\hlam{x}{\hadd{x}{\hehole_1}}}{5}
      }
      {
        \hadd{5}{\hehole_1}
      }
\end{align*}

Substitutions also occur inside non-empty holes: otherwise, free variables
would appear in the result, which would break any familiar notion of
preservation.
\begin{align*}
  \pstep
      {
        \hap{\hlam{x}{\hadd{x}{\hhole{x}_1}}}{5}
      }
      {
        \hadd{5}{\hhole{5}_1}
      }
\end{align*}
We also evaluate inside the non-empty holes:
\begin{align*}
  \pstep{
    \pstep
        {
          \hap{\hlam{x}{\hadd{x}{\hhole{\hadd{x}{x}}}_1}}{5}
        }
        {
          \hadd{5}{\hhole{\hadd{5}{5}}_1}
        }
  }{\hadd{5}{\hhole{10}_1}}
\end{align*}
This allows a programmer to observe the behavior of incomplete solutions
that may not yet have a type consistent with their surroundings.

\subsection{Extended Hazel}
To consider a more realistic we use an ML-like syntax outside Hazelnut that
should be understood intuitively. Believe an understanding of the dynamic
semantics will guide an extension of Hazelnut to include constructs like
pattern matching, ADTs, and recursive functions.

Imagine a programmer implementing $$\mathbf{map} : (\alpha \to \beta) \to
\alpha ~\mathit{list} \to \beta ~\mathit{list}$$ from the informal
specification that the function be applied to every list element uniformly.
She might arrive at the incomplete term
\begin{lstlisting}
fun map f [] = []
  | map f (x::xs) = $\hehole_1$::(map f l)
\end{lstlisting}
if she knows the pattern of recursion, but are not sure what to do with
each element yet. Here, evaluating the partial program on a small example
produces a trace: because the body of the function is not yet final after
substitution, the function calls continue to evaluate.
\begin{lstlisting}
   map ($\lambda x.$x+1) [1, 2]
$\mapsto$ $\hehole_1$::(map ($\lambda x.$x+1) [2])
$\mapsto$ $\hehole_1$::$\hehole_1$::(map ($\lambda x.$x+1) [])
$\mapsto$ $\hehole_1$::$\hehole_1$::[]
\end{lstlisting}
Each hole in the trace is equipped with a tableau that can be inspected by
the programmer, mapping the in-scope variables names from the source to the
types and values at run-time and showing the goal-type for the hole---shown
for the two instantiations of $\hehole_1$ above in Table \ref{tabx}.

\begin{table}
  \caption{hole context tableaux}
  \label{tabx}
  \begin{subtable}{.5\linewidth}
    \caption{goal: $\beta=$ int}
    \centering
        {
          \footnotesize
          \begin{tabular}{c|c|c}
            var & $\htau$ & val\\
            \hline
            f & int $\to$ int & $\lambda x.x$+1\\
            l & int list & [1,2]\\
            x & int & 1\\
            xs & int list & [2]\\
          \end{tabular}
        }
  \end{subtable}%
  \begin{subtable}{.5\linewidth}
    \caption{goal: $\beta=$ int}
    \centering
        {
          \footnotesize
          \begin{tabular}{c|c|c}
            var & $\htau$ & val\\
            \hline
            f & int $\to$ int & $\lambda x.$x+1\\
            l & int list & [2]\\
            x & int & 2\\
            xs & int list & []\\
          \end{tabular}
        }
  \end{subtable}
\end{table}

This trace might lead the programmer to have more confidence about their
solution so far, and to have a good idea for a candidate
completion---namely $\hhole{\texttt{f x}}$. If she makes this update and
then reruns the example, she will see that she has indeed satisfied the
specification.
\hspace{1cm}
\begin{lstlisting}
   map ($\lambda x.$x+1) [1, 2]
$\mapsto$ $\hhole{\hap{(\lambda x.x+1)}{1}}_1$::(map ($\lambda x.$x+1) [2])
$\mapsto$ $\hhole{\hadd{1}{1}}_1$::(map ($\lambda x.$x+1) [2])
$\mapsto$ $\hhole{2}_1$::(map ($\lambda x.$x+1) [2])
$\mapsto$ $\hhole{2}_1$::$\hhole{\hap{\lambda x.x+1}{2}}_1$::(map ($\lambda x.$x+1) [])
$\mapsto$ $\hhole{2}_1$::$\hhole{\hadd{2}{1}}_1$::(map ($\lambda x.$x+1) [])
$\mapsto$ $\hhole{2}_1$::$\hhole{3}_1$::(map ($\lambda x.$x+1) [])
$\mapsto$ $\hhole{2}_1$::$\hhole{3}_1$::[]
\end{lstlisting}
